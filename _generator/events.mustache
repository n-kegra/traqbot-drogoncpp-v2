#ifndef TRAQBOT_EVENT_H
#define TRAQBOT_EVENT_H

#include <string>
#include <vector>
#include <variant>
#include <drogon/drogon.h>
#include <json/json.h>
#include <traQBot/models.h>

namespace traQBot {

{{#events}}
{{{modelStruct}}}
{{/events}}
struct UnknownEvent {};

class Bot {
    std::string verification_token, token, uuid, username, home_channel_id;
{{#events}}
    std::function<void({{eventTypename}})> on_{{eventIdLower}}_callback;
{{/events}}
    auto loadEnv(const std::string& name) {
        auto tmp = std::getenv(name.c_str());
        if(tmp){
            return std::string(tmp);
        } else {
            throw std::runtime_error(name + " is not set");
        }
    }
public:
    std::string get_uuid() { return uuid; }
    std::string get_username() { return username; }
    std::string get_home_channel_id() { return home_channel_id; }
    traQBot(std::string _verification_token, std::string _token) :
        verification_token(_verification_token),
        token(_token)
    {
        drogon::app().registerHandler("/", [this](const drogon::HttpRequestPtr &req,
        std::function<void (const drogon::HttpResponsePtr &)> &&callback) {
            auto resp = drogon::HttpResponse::newHttpResponse();
            callback(resp);

            if(eventData.token == verification_token){
                resp->setStatusCode(drogon::HttpStatusCode::k204NoContent);
            } else {
                resp->setStatusCode(drogon::HttpStatusCode::k400BadRequest);
                return;
            }

            auto event = req.getHeader("X-TRAQ-BOT-EVENT");
            auto requestId = req.getHeader("X-TRAQ-BOT-REQUEST-ID");
            auto token = req.getHeader("X-TRAQ-BOT-TOKEN");
            auto json = req.getJsonObject();
            if (json) {
        {{#events}}
                if (event == "{{eventId}}") {
                    const auto data = traQBot::{{eventObjname}}().fromJson(*json);
                    this->on_{{eventIdLower}}_callback(data);
                } else
        {{/events}}
                {
                    // Unknown event;
                }
            }
        });
        drogon::app().getLoop()->runAfter(std::chrono::seconds(0), [](){
            traQApi::MeApi cli("https://q.trap.jp", "/api/v3");
            const auto [_res, _resp, me] = cli.getMe();
            if(me) {
                uuid = me->id;
                username = me->name;
                home_channel_id = me->homeChannel;
            }
        });
    }
{{#events}}
    template<class F>
    void on_{{eventIdLower}}(F callback) { on_{{eventIdLower}}_callback = callback; }
{{/events}}

    void enable_mysql_ns() {
        auto mariadb_hostname = loadEnv("NS_MARIADB_HOSTNAME");
        auto mariadb_database = loadEnv("NS_MARIADB_DATABASE");
        auto mariadb_username = loadEnv("NS_MARIADB_USER");
        auto mariadb_password = loadEnv("NS_MARIADB_PASSWORD");
        drogon::app().createDbClient("mysql", mariadb_hostname, 3306, mariadb_database, mariadb_username, mariadb_password);
    }
    void start() {
        drogon::app().run();
    }
}

}

namespace drogon {

template <>
inline traQBot::EventData fromRequest(const HttpRequest& req) {
    auto event = req.getHeader("X-TRAQ-BOT-EVENT");
    auto requestId = req.getHeader("X-TRAQ-BOT-REQUEST-ID");
    auto token = req.getHeader("X-TRAQ-BOT-TOKEN");
    auto json = req.getJsonObject();
    traQBot::EventData data;
    data.requestId = requestId;
    data.event = traQBot::EventType::Unknown;
    data.token = token;
    if (json) {
{{#events}}
        if (event == "{{eventId}}") {
            data.event = traQBot::EventType::{{eventTypename}};
            data.payload = traQBot::{{eventObjname}}().fromJson(*json);
        } else
{{/events}}
        {
            data.event = traQBot::EventType::Unknown;
        }
    }
    return data;
}

}

#endif
